#!/usr/bin/env python

import numpy
import h5py
import pyscf.lib.parameters as param
from pyscf.scf import hf
from pyscf.pbc import gto, scf, dft, df
from pyscf.pbc import lib as libpbc
from pyscf.pbc.tools import pbc
from pyscf import lib

name = 'k-lif'

cell = libpbc.chkfile.load_cell(name+'.chk')
cell.ecp = None
mo_coeff_kpts = lib.chkfile.load(name+'.chk', 'scf/mo_coeff')
mo_occ_kpts = lib.chkfile.load(name+'.chk', 'scf/mo_occ')
kpts = lib.chkfile.load(name+'.chk', 'scf/kpts')
nkpts = len(mo_occ_kpts)
dm_kpts = [hf.make_rdm1(mo_coeff_kpts[k], mo_occ_kpts[k]) for k in range(nkpts)]
dm_kpts = lib.asarray(dm_kpts)

#grid = dft.gen_grid.UniformGrids(cell)
#grid = dft.gen_grid.BeckeGrids(cell)
#grid.level = 3
#grid.prune = None
#grid.verbose = 4
#grid.build()

#coords = grid.coords
#weights = grid.weights
#ao = dft.numint.eval_ao_kpts(cell, coords, kpts=kpts, deriv=0)
#rho = 0.0
#for k in range(nkpts):
#    rho += dft.numint.eval_rho2(cell, ao[k], mo_coeff_kpts[k], mo_occ_kpts[k], xctype='LDA')
#for k in range(nkpts):
#    rho += dft.numint.eval_rho(cell, ao[k], dm[k], xctype='MGGA')
#rho *= 1./nkpts
#print('Rho = %.12f' % numpy.einsum('i,i->', rho, weights))
#print('Cell electrons = %.12f' % cell.nelectron)

supercell = [2,2,2]
grid = [80,80,80]
ngrid = numpy.asarray(grid)
nX, nY, nZ = tuple((numpy.asarray(grid)-1)*numpy.asarray(supercell) + 1)
nx, ny, nz = numpy.asarray(grid)

super_cell = pbc.super_cell(cell, supercell)
lattice = super_cell.lattice_vectors() * param.BOHR
symbols = [atom[0] for atom in super_cell._atom]
cart = numpy.asarray([(numpy.asarray(atom[1])* param.BOHR).tolist() for atom in super_cell._atom])
num_atoms = super_cell.natm		

qv = lib.cartesian_prod([numpy.arange(i) for i in ngrid])
a_frac = numpy.einsum('i,ij->ij', 1./(ngrid - 1), cell.lattice_vectors())
coords = numpy.dot(qv, a_frac)
#gs = cell.gs
#ngs = 2*numpy.asarray(gs)+1
#qv = lib.cartesian_prod([numpy.arange(x) for x in ngs])
#a_frac = numpy.einsum('i,ij->ij', 1./ngs, cell.lattice_vectors())
#coords = numpy.dot(qv, a_frac)

ao = dft.numint.eval_ao_kpts(cell, coords, kpts=kpts, deriv=0)
rho = 0.0
for k in range(nkpts):
    rho += dft.numint.eval_rho2(cell, ao[k], mo_coeff_kpts[k], mo_occ_kpts[k], xctype='LDA')
rho *= 1./nkpts
valores = numpy.empty([nX, nY, nZ])
valores_tmp = numpy.empty([nX, nY, nZ])
rho = rho.reshape(nx,ny,nz)
#for x in range(supercell[0]):
#	for y in range(supercell[1]):
#		for z in range(supercell[2]):					
#			valores_tmp[:nx,:ny,((nz-1)*z):((nz-1)*z + nz)] = rho
#		valores_tmp[:,((ny-1)*y):((ny-1)*y + ny),:] = valores_tmp[:,:ny,:]
#	valores[((nx-1)*x):((nx-1)*x + nx),:,:] = valores_tmp[:nx,:,:]

name = 'k-lif-rho'
with open(name + '_den.xsf', 'w') as f:
	f.write('Generated by pyscf\n\n')		
	f.write('CRYSTAL\n')
	f.write('PRIMVEC\n')	
	for row in range(3):
		f.write('%10.7f  %10.7f  %10.7f\n' % (lattice[0, row], lattice[1, row], lattice[2, row]))	
	f.write('PRIMVEC\n')
	for row in range(3):
		f.write('%10.7f  %10.7f  %10.7f\n' % (lattice[0, row], lattice[1, row], lattice[2, row]))	
	f.write('PRIMCOORD\n')
	f.write('%3d %3d\n' % (num_atoms, 1))
	for atom in range(len(symbols)):
		f.write('%s  %7.7f  %7.7f  %7.7f\n' % (symbols[atom], cart[atom][0], cart[atom][1], cart[atom][2]))				
	f.write('\n\n')			
 	f.write('BEGIN_BLOCK_DATAGRID_3D\n3D_field\nBEGIN_DATAGRID_3D_UNKNOWN\n')	
 	f.write('   %5d	 %5d  %5d\n' % (nX, nY, nZ))		
 	f.write('   %10.7f  %10.7f  %10.7f\n' % tuple(numpy.zeros(3).tolist()))
 	for row in range(3):
 		f.write('   %10.7f  %10.7f  %10.7f\n' % (lattice[0, row], lattice[1, row], lattice[2, row]))	
 	fmt = ' %13.5e' * nX + '\n'
 	for iz in range(nZ):
 		for iy in range(nY):
 			f.write(fmt % tuple(valores[:,iy,iz].tolist()))		
#    for ix in range(nx):
#        for iy in range(ny):
#            for iz in range(0,nz,6):
#                remainder  = (nz-iz)
#                if (remainder > 6 ):
#                    fmt = '%13.5E' * 6 + '\n'
#                    f.write(fmt % tuple(rho[ix,iy,iz:iz+6].tolist()))
#                else:
#                    fmt = '%13.5E' * remainder + '\n'
#                    f.write(fmt % tuple(rho[ix,iy,iz:iz+remainder].tolist()))
#                    break
 	f.write('\n')									
 	f.write('END_DATAGRID_3D\nEND_BLOCK_DATAGRID_3D')		

# ELF
#cf = 2.87123400018819
#fivethird = 5.0/3.0
#if (rho.gt.0d0) then
#  gradmod = numpy.sqrt(rho[1]*rho[1]+rho[2]*rho[2])+rho[3]*rho[3])
#  ds = rho[6] - gradmod*gradmod/(rho[0]*8.0)
#else 
#  ds = rho[6]
#endif
#kinp = ds
#ds0 = cf*rho[0]**fivethird
#den = ds/ds0
#elf = 1.0/(1.0+den*den)

#coord = mol.atom_coords()
#box = numpy.max(coord,axis=0) - numpy.min(coord,axis=0) + 6
#boxorig = numpy.min(coord,axis=0) - 3
# .../(nx-1) to get symmetric mesh
# see also the discussion on https://github.com/sunqm/pyscf/issues/154
#xs = numpy.arange(nx) * (box[0] / (nx - 1))
#ys = numpy.arange(ny) * (box[1] / (ny - 1))
#zs = numpy.arange(nz) * (box[2] / (nz - 1))
#coords = lib.cartesian_prod([xs,ys,zs])
#coords = numpy.asarray(coords, order='C') - (-boxorig)
#ngrids = nx * ny * nz
#blksize = min(8000, ngrids)
#rho = numpy.empty(ngrids)
#ao = None
#for ip0, ip1 in gen_grid.prange(0, ngrids, blksize):
#    ao = numint.eval_ao(mol, coords[ip0:ip1], out=ao)
#    rho[ip0:ip1] = numint.eval_rho(mol, ao, dm)
#rho = rho.reshape(nx,ny,nz)

#with open(outfile, 'w') as f:
#    f.write('Electron density in real space (e/Bohr^3)\n')
#    f.write('PySCF Version: %s  Date: %s\n' % (pyscf.__version__, time.ctime()))
#    f.write('%5d' % mol.natm)
#    f.write('%12.6f%12.6f%12.6f\n' % tuple(boxorig.tolist()))
#    f.write('%5d%12.6f%12.6f%12.6f\n' % (nx, xs[1], 0, 0))
#    f.write('%5d%12.6f%12.6f%12.6f\n' % (ny, 0, ys[1], 0))
#    f.write('%5d%12.6f%12.6f%12.6f\n' % (nz, 0, 0, zs[1]))
#    for ia in range(mol.natm):
#        chg = mol.atom_charge(ia)
#        f.write('%5d%12.6f'% (chg, chg))
#        f.write('%12.6f%12.6f%12.6f\n' % tuple(coord[ia]))
#
#    for ix in range(nx):
#        for iy in range(ny):
#            for iz in range(0,nz,6):
#                remainder  = (nz-iz)
#                if (remainder > 6 ):
#                    fmt = '%13.5E' * 6 + '\n'
#                    f.write(fmt % tuple(rho[ix,iy,iz:iz+6].tolist()))
#                else:
#                    fmt = '%13.5E' * remainder + '\n'
#                    f.write(fmt % tuple(rho[ix,iy,iz:iz+remainder].tolist()))
#                    break


